<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitch Chat Overlay with 7TV</title>
    <style>
        :root {
            --chat-background: rgba(18, 18, 18, 0.8);
            --message-background: rgba(30, 30, 30, 0.6);
            --text-color: #ffffff;
            --default-name-color: #ff4081;
            --border-radius: 8px;
            --font-size: 16px;
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            --emote-size-multiplier: 1.75;
            --emote-size: calc(var(--font-size) * var(--emote-size-multiplier));
            --container-width: 100%;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-family);
            background: transparent;
            color: var(--text-color);
            font-size: var(--font-size);
            display: flex;
            flex-direction: column;
        }

        *,
        *:before,
        *:after {
            box-sizing: border-box;
        }

        #chat-container {
            flex: 1;
            margin: 0;
            padding: 16px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            -ms-overflow-style: none;
            scrollbar-width: none;
            background: var(--chat-background);
            height: calc(100vh - calc(var(--font-size) * 2));
            position: relative;
        }

        #chat-container::-webkit-scrollbar {
            display: none;
        }

        /* Добавляем перенос текста и ограничение ширины блока сообщения */
        .chat-message {
            animation: slideIn 0.3s ease-out;
            opacity: 1;
            padding: 8px 12px;
            background: var(--message-background, #25252b);
            border-radius: var(--border-radius, 6px);
            animation: slideIn 0.3s ease-out;
            margin-bottom: 8px;
            line-height: 1.4;
            max-width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            display: block;
            clear: both;
            font-size: inherit;
            /* Шрифт унаследован, будет меняться через JavaScript */
            font-family: inherit;
            /* Шрифт унаследован, будет меняться через JavaScript */
        }

        .chat-message.fade-out {
            animation: fadeOut 0.3s ease-out forwards;
        }

        .message-content {
            display: block;
            /* Текст сообщения обтекает бейджи и имя */
            word-break: break-word;
            /* Разрешаем перенос длинных слов */
            overflow-wrap: break-word;
            /* Перенос слов для совместимости */
            margin-top: 4px;
            /* Небольшой отступ сверху */
            clear: both;
            /* Текст начинается под именем и бейджами */
        }

        .username {
            float: left;
            /* Имя выравнивается влево рядом с бейджами */
            font-weight: 600;
            display: inline-block;
            /* Имя пользователя на одной линии */
            white-space: nowrap;
            /* Запрещаем перенос имени */
            vertical-align: middle;
            /* Выравнивание имени */
            margin-right: 8px;
            /* Отступ между именем и текстом */
            color: var(--default-name-color);
        }

        .chat-message .username {
            font-weight: 600;
            display: inline;
            white-space: nowrap;
            margin-right: 4px;
            color: var(--default-name-color);
        }

        .message-content {
            display: block;
            /* Текст сообщения обтекает бейджи и имя */
            word-break: break-word;
            /* Разрешаем перенос длинных слов */
            overflow-wrap: break-word;
            /* Перенос слов для совместимости */
            margin-top: 4px;
            /* Небольшой отступ сверху */
            clear: both;
            /* Текст начинается под именем и бейджами */
        }

        .chat-message .message-content {
            display: inline;
            /* Текст идет сразу за именем */
            word-break: break-word;
        }

        .username::after {
            content: ': ';
            white-space: pre;
        }

        .message-wrapper {
            display: inline-flex;
            flex-wrap: wrap;
            min-width: 0;
            max-width: 100%;
            word-wrap: break-word;
        }

        .message {
            display: inline;
            word-break: break-word;
            white-space: pre-wrap;
            max-width: 100%;
            overflow-wrap: break-word;
        }

        .emote {
            height: var(--emote-size);
            width: auto;
            max-width: calc(var(--emote-size) * 1.5);
            vertical-align: middle;
            object-fit: contain;
            display: inline-block;
            margin: 0 2px;
            transition: opacity 0.2s ease-in-out;
        }

        .badges-container {
            float: left;
            /* Бейджи выравниваются влево */
            display: inline-block;
            /* Бейджи на одной линии */
            vertical-align: middle;
            /* Выравнивание по вертикали */
            margin-right: 4px;
            /* Отступ между бейджами и именем */
        }

        .chat-badge {
            width: 18px;
            /* Размер бейджа */
            height: 18px;
            display: inline-block;
            vertical-align: middle;
            /* Выравнивание бейджей */
        }

        .highlighted-message {
            background-color: rgba(255, 0, 0, 0.1);
            /* Полупрозрачный красный фон */
            border-left: 4px solid #ff0000;
            /* Ярко-красная полоса слева */
            border-right: 4px solid #ff0000;
            /* Ярко-красная полоса слева */
            padding: 6px 10px;
            /* Внутренние отступы */
            border-radius: 4px;
            /* Закруглённые углы */
            color: inherit;
            /* Наследуем цвет текста */
        }

        .chat-link {
            color: #00b7ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .chat-link:hover {
            color: #66d9ff;
            text-decoration: underline;
        }

        .chat-command {
            color: #ff9966;
            font-weight: bold;
        }

        .win11-window {
            background: var(--chat-background);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .win11-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: var(--font-size);
            color: #fff;
            margin-left: 10px;
            height: 100%;
        }

        .win11-title-icon {
            width: calc(var(--font-size) * 1.2);
            height: calc(var(--font-size) * 1.2);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
        }

        .win11-title-icon svg {
            width: 100%;
            height: 100%;
        }

        .win11-titlebar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: 32px;
            /* минимальная высота */
            height: calc(var(--font-size) * 2);
            /* адаптивная высота относительно размера шрифта */
            background: rgba(32, 32, 32, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            user-select: none;
            padding: 0;
        }

        .win11-controls {
            display: flex;
            height: 100%;
        }

        .win11-button {
            width: calc(var(--font-size) * 3);
            /* ширина кнопки относительно шрифта */
            height: 100%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            outline: none;
            cursor: pointer;
            color: #ffffff;
            transition: background-color 0.1s;
            margin: 0;
            padding: 0;
        }

        .win11-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .win11-button svg {
            width: calc(var(--font-size) * 0.8);
            height: calc(var(--font-size) * 0.8);
        }

        .win11-button.minimize svg {
            width: 46px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .win11-button.maximize svg {
            width: 15px;
            height: 15px;
        }

        .win11-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .win11-button.close {
            background-color: #c42b1c;
        }

        .win11-button.close svg {
            width: 19px;
            height: 19px;
        }

        .clip-container {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            background-color: #9146FF;
            border-radius: 4px;
            animation: clipAppear 0.3s ease-out;
        }

        .clip-link {
            color: white;
            text-decoration: none;
            font-size: 14px;
            margin-left: 6px;
        }

        .clip-link::before {
            content: "📎";
            font-size: 18px;
            margin-right: 6px;
        }

        .first-message {
            background-color: rgba(225, 0, 255, 0.1);
            /* Полупрозрачный желтый фон */
            border-left: 4px solid #b700ff54;
            /* Ярко-красная полоса слева */
            border-right: 4px solid #b700ff54;
            border-radius: 4px;
            /* Закруглённые углы */
            padding: 8px;
        }

        .channel-reward {
            background-color: rgba(46, 204, 113, 0.1);
            border-left: 4px solid #2ecc71;
            border-right: 4px solid #2ecc71;
        }


        @keyframes firstMessageHighlight {
            0% {
                background-color: rgba(255, 255, 0, 0.5);
            }

            100% {
                background-color: transparent;
            }
        }

        @keyframes clipAppear {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes emoteAppear {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            0% {
                opacity: 1;
                transform: translateX(0);
            }

            100% {
                opacity: 0;
                transform: translateX(-10px);
            }
        }

        @keyframes slideIn {
            from {
                transform: translateX(-20px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <div id="chat-container"></div>
    <script>
        // Комплексный логгер с поддержкой разных уровней логирования
        class Logger {
            constructor(debugMode = false) {
                this.debugMode = debugMode;
                this.styles = {
                    debug: 'color: #7CB9E8',
                    info: 'color: #98FB98',
                    warn: 'color: #FFD700',
                    error: 'color: #FF6B6B',
                    timestamp: 'color: #C0C0C0',
                    username: 'font-weight: bold'
                };
            }

            formatTimestamp(date) {
                return date.toISOString().split('T')[1].slice(0, -1);
            }

            log(level, message) {
                const timestamp = this.formatTimestamp(new Date());
                console.log(
                    `%c[${timestamp}] %c[${level.toUpperCase()}] ${message}`,
                    this.styles.timestamp,
                    this.styles[level]
                );
            }

            debug(message) {
                if (!this.debugMode) return;
                if (typeof message === 'object') {
                    if (message.tags && message.message) {
                        // Специальная обработка сообщений чата
                        const username = message.tags['display-name'] || message.username;
                        const chatMessage = message.message.trim();
                        console.log(
                            `%c[${this.formatTimestamp(new Date())}] %c[DEBUG] %c${username}: %c${chatMessage}`,
                            this.styles.timestamp,
                            this.styles.debug,
                            this.styles.username,
                            'color: white'
                        );
                        if (this.debugMode && Object.keys(message.tags).length > 0) {
                            console.groupCollapsed('Message Details');
                            console.log('Tags:', message.tags);
                            console.log('Badges:', message.badges);
                            console.groupEnd();
                        }
                    } else {
                        this.log('debug', JSON.stringify(message));
                    }
                } else {
                    this.log('debug', message);
                }
            }

            info(message) {
                if (this.debugMode) {
                    this.log('info', message);
                }
            }

            warn(message) {
                if (this.debugMode) {
                    this.log('warn', message);
                }
            }

            error(message) {
                if (this.debugMode) {
                    this.log('error', message);
                    if (message instanceof Error) {
                        console.error('Stack trace:', message.stack);
                    }
                }
            }
        }
        // Кэш эмоутов
        class EmoteCache {
            constructor(logger) {
                this.emotes = new Map();
                this.logger = logger;
            }

            async fetch7TVEmotes(channelId) {
                try {
                    const response = await fetch(`https://7tv.io/v3/users/twitch/${channelId}`);
                    if (!response.ok) throw new Error(`Failed to fetch 7TV emotes: ${response.status}`);
                    const data = await response.json();
                    if (data && data.emote_set && data.emote_set.emotes) {
                        data.emote_set.emotes.forEach(emote => {
                            this.emotes.set(emote.name, `https://cdn.7tv.app/emote/${emote.id}/3x.webp`);
                        });
                    }
                } catch (error) {
                    this.logger.error('Error fetching 7TV emotes:', error);
                }
            }

            getEmoteUrl(emoteName) {
                return this.emotes.get(emoteName);
            }
        }
        const emoteCache = new EmoteCache();
        async function processMessageContent(container, text, parsedMessage, isTypewriterEffect, typewriterSpeed, userColors = new Map()) {
            // Парсим эмоуты из тегов
            function parseEmotes(emoteTag, messageText) {
                if (!emoteTag || emoteTag === true) return [];

                const emotes = [];
                const emotesArray = emoteTag.split('/');

                for (const emote of emotesArray) {
                    const [emoteId, positions] = emote.split(':');
                    if (!positions) continue;

                    positions.split(',').forEach(position => {
                        const [start, end] = position.split('-').map(Number);
                        emotes.push({
                            id: emoteId,
                            start,
                            end,
                            name: messageText.slice(start, end + 1),
                            url: `https://static-cdn.jtvnw.net/emoticons/v2/${emoteId}/default/dark/3.0`
                        });
                    });
                }

                return emotes.sort((a, b) => a.start - b.start);
            }

            const urlRegex = /(https?:\/\/[^\s]+)/;
            const commandRegex = /^!/;
            const twitchEmotes = parseEmotes(parsedMessage.tags.emotes, text);

            if (twitchEmotes.length > 0) {
                let lastIndex = 0;

                for (const emote of twitchEmotes) {
                    // Обрабатываем текст до эмоута
                    if (emote.start > lastIndex) {
                        const textBefore = text.slice(lastIndex, emote.start);
                        const words = textBefore.split(/\s+/);
                        for (const word of words) {
                            await processWord(word);
                        }
                    }

                    // Добавляем Twitch эмоут
                    const emoteImg = document.createElement('img');
                    emoteImg.src = emote.url;
                    emoteImg.alt = emote.name;
                    emoteImg.className = 'emote';
                    container.appendChild(emoteImg);

                    if (isTypewriterEffect) {
                        await new Promise(resolve => setTimeout(resolve, typewriterSpeed));
                    }

                    lastIndex = emote.end + 1;
                }

                // Обрабатываем оставшийся текст после последнего эмоута
                if (lastIndex < text.length) {
                    const remainingText = text.slice(lastIndex);
                    const words = remainingText.split(/\s+/);
                    for (const word of words) {
                        await processWord(word);
                    }
                }
            } else {
                const words = text.split(/\s+/);
                for (const word of words) {
                    await processWord(word);
                }
            }

            async function processWord(word) {
                const clipRegex = /(?:https?:\/\/)?(?:clips\.twitch\.tv\/|(?:www\.)?twitch\.tv\/\w+\/clip\/)([a-zA-Z0-9-_]+)/i;
                const clipMatch = word.match(clipRegex);

                if (clipMatch) {
                    const clipContainer = document.createElement('span');
                    clipContainer.className = 'clip-container';

                    const clipLink = document.createElement('a');
                    clipLink.href = word;
                    clipLink.className = 'clip-link';
                    clipLink.target = '_blank';
                    clipLink.rel = 'noopener noreferrer';
                    clipLink.textContent = 'Прикрепленный клип';

                    clipContainer.appendChild(clipLink);
                    container.appendChild(clipContainer);
                    container.appendChild(document.createTextNode(' '));

                    if (isTypewriterEffect) {
                        await new Promise(resolve => setTimeout(resolve, typewriterSpeed));
                    }

                    return;
                }

                // Остальной код остается без изменений
                if (word.length === 0) return;

                if (word.startsWith('@')) {
                    // Обработка тега пользователя
                    const username = word.slice(1).toLowerCase();
                    const tagSpan = document.createElement('span');

                    if (isTypewriterEffect) {
                        for (const char of word) {
                            const charSpan = document.createElement('span');
                            charSpan.textContent = char;
                            if (userColors.has(username)) {
                                charSpan.style.color = userColors.get(username);
                                charSpan.style.fontWeight = 'bold';
                            }
                            tagSpan.appendChild(charSpan);
                            await new Promise(resolve => setTimeout(resolve, typewriterSpeed));
                        }
                        tagSpan.appendChild(document.createTextNode(' '));
                    } else {
                        tagSpan.textContent = word + ' ';
                        if (userColors.has(username)) {
                            tagSpan.style.color = userColors.get(username);
                            tagSpan.style.fontWeight = 'bold';
                        }
                    }
                    container.appendChild(tagSpan);

                } else if (urlRegex.test(word)) {
                    // Обработка ссылок
                    const linkElement = document.createElement('a');
                    linkElement.href = word;
                    linkElement.className = 'chat-link';
                    linkElement.target = '_blank';
                    linkElement.rel = 'noopener noreferrer';

                    if (isTypewriterEffect) {
                        for (const char of word) {
                            const charSpan = document.createElement('span');
                            charSpan.textContent = char;
                            linkElement.appendChild(charSpan);
                            await new Promise(resolve => setTimeout(resolve, typewriterSpeed));
                        }
                    } else {
                        linkElement.textContent = word;
                    }

                    container.appendChild(linkElement);
                    container.appendChild(document.createTextNode(' '));

                } else if (commandRegex.test(word)) {
                    // Обработка команд
                    const commandSpan = document.createElement('span');
                    commandSpan.className = 'chat-command';

                    if (isTypewriterEffect) {
                        for (const char of word) {
                            const charSpan = document.createElement('span');
                            charSpan.textContent = char;
                            commandSpan.appendChild(charSpan);
                            await new Promise(resolve => setTimeout(resolve, typewriterSpeed));
                        }
                    } else {
                        commandSpan.textContent = word;
                    }

                    container.appendChild(commandSpan);
                    container.appendChild(document.createTextNode(' '));

                } else {
                    // Проверяем 7TV эмоуты
                    const emoteUrl = emoteCache.getEmoteUrl(word);
                    if (emoteUrl) {
                        const emoteImg = document.createElement('img');
                        emoteImg.src = emoteUrl;
                        emoteImg.alt = word;
                        emoteImg.className = 'emote';
                        container.appendChild(emoteImg);
                    } else if (isTypewriterEffect) {
                        for (const char of word) {
                            container.appendChild(document.createTextNode(char));
                            await new Promise(resolve => setTimeout(resolve, typewriterSpeed));
                        }
                        container.appendChild(document.createTextNode(' '));
                    } else {
                        container.appendChild(document.createTextNode(`${word} `));
                    }
                }
            }
        }
        class TwitchChat {
            constructor(channel, channelId, isTypewriterEffect, typewriterSpeed, fontSize, fontFamily, logger, win11Style) {
                // Инициализируем окно Windows 11
                if (win11Style) {
                    document.body.innerHTML = `
                <div class="win11-window">
                    <div class="win11-titlebar">
                        <div class="win11-title">
                            <div class="win11-title-icon">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M2 2.5C2 1.67157 2.67157 1 3.5 1H12.5C13.3284 1 14 1.67157 14 2.5V10.5C14 11.3284 13.3284 12 12.5 12H10L8 15L6 12H3.5C2.67157 12 2 11.3284 2 10.5V2.5ZM3.5 2C3.22386 2 3 2.22386 3 2.5V10.5C3 10.7761 3.22386 11 3.5 11H6.5L8 13.3333L9.5 11H12.5C12.7761 11 13 10.7761 13 10.5V2.5C13 2.22386 12.7761 2 12.5 2H3.5Z" fill="white"/>
                                    <path d="M7 6.5C7 6.77614 6.77614 7 6.5 7C6.22386 7 6 6.77614 6 6.5C6 6.22386 6.22386 6 6.5 6C6.77614 6 7 6.22386 7 6.5Z" fill="white"/>
                                    <path d="M10 6.5C10 6.77614 9.77614 7 9.5 7C9.22386 7 9 6.77614 9 6.5C9 6.22386 9.22386 6 9.5 6C9.77614 6 10 6.22386 10 6.5Z" fill="white"/>
                                </svg>
                            </div>
                            <span>Twitch Chat - ${channel}</span>
                        </div>
                        <div class="win11-controls">
                            <button class="win11-button minimize">
                                <svg viewBox="0 0 32 32">
                                    <path d="M6,16 L26,16" stroke="currentColor" stroke-width="1" />
                                </svg>
                            </button>
                            <button class="win11-button maximize">
                                <svg viewBox="0 0 32 32">
                                    <rect x="8" y="8" width="16" height="16" stroke="currentColor" stroke-width="1" fill="none" />
                                </svg>
                            </button>
                            <button class="win11-button close">
                                <svg viewBox="0 0 32 32">
                                    <path d="M10,10 L22,22 M10,22 L22,10" stroke="currentColor" stroke-width="1" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div id="chat-container"></div>
                </div>
            `;
                    // Добавляем обработчики событий
                    document.querySelector('.win11-button.minimize').addEventListener('click', () => {
                        // Здесь можно добавить анимацию сворачивания
                    });
                    document.querySelector('.win11-button.maximize').addEventListener('click', () => {
                        document.querySelector('.win11-window').classList.toggle('maximized');
                    });
                    document.querySelector('.win11-button.close').addEventListener('click', () => {
                        // Здесь можно добавить анимацию закрытия
                    });
                } else {
                    document.body.innerHTML = `<div id="chat-container"></div>`;
                }

                // Остальные инициализации
                this.channel = channel.toLowerCase();
                this.channelId = channelId;
                this.isTypewriterEffect = isTypewriterEffect;
                this.typewriterSpeed = typewriterSpeed;
                this.fontSize = fontSize;
                this.fontFamily = fontFamily;
                this.logger = logger;
                this.debug = logger.debugMode;

                this.userColors = new Map();
                this.displayedUsers = new Set();

                this.badgeUrls = {
                    broadcaster: 'https://static-cdn.jtvnw.net/badges/v1/5527c58c-fb7d-422d-b71b-f309dcb85cc1/3',
                    moderator: 'https://static-cdn.jtvnw.net/badges/v1/3267646d-33f0-4b17-b3df-f923a41db1d0/3',
                    vip: 'https://static-cdn.jtvnw.net/badges/v1/b817aba4-fad8-49e2-b88a-7cc744dfa6ec/3',
                    subscriber: 'https://static-cdn.jtvnw.net/badges/v1/f3130f22-0a46-4bce-97fe-9a0729fcb055/3',
                    premium: 'https://static-cdn.jtvnw.net/badges/v1/bbbe0db0-a598-423e-86d0-f9fb98ca1933/3',
                    no_video: 'https://static-cdn.jtvnw.net/badges/v1/199a0dba-58f3-494e-a7fc-1fa0a1001fb8/3',
                    no_audio: 'https://static-cdn.jtvnw.net/badges/v1/aef2cd08-f29b-45a1-8c12-d44d7fd5e6f0/3',
                    founder: 'https://static-cdn.jtvnw.net/badges/v1/511b78a9-ab37-472f-9569-457753bbe7d3/3',
                    partner: 'https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f6-41d0-ab77-b780518f00a3/3'
                };
                
                this.messageStats = {
                    lastCleanup: Date.now(),
                    messagesPerSecond: 0,
                    lastMessageCount: 0,
                    performanceHistory: []
                };

                this.cleanupConfig = {
                    minMessagesBeforeCleanup: 15,
                    maxMessagesBeforeForceCleanup: 30,
                    cleanupInterval: 1000,
                    performanceThreshold: 30,
                    messageRetentionTime: 15000,
                    batchSize: 5,
                    cleanupDelay: 50
                };

                this.isCleanupInProgress = false;
                this.lastScrollPosition = 0;
                this.isUserScrolling = false;
                this.scrollTimeout = null;

                this.setupScrollHandlers();
                this.startPerformanceMonitoring();
                this.startAdaptiveCleanup();
                this.applyStyles();
                this.connect();
            }
            startPerformanceMonitoring() {
                let lastTime = performance.now();
                let frames = 0;

                const measurePerformance = () => {
                    const currentTime = performance.now();
                    frames++;

                    if (currentTime - lastTime >= 1000) {
                        const fps = frames * (1000 / (currentTime - lastTime));
                        this.messageStats.performanceHistory.push(fps);

                        // Сохраняем только последние 10 измерений
                        if (this.messageStats.performanceHistory.length > 10) {
                            this.messageStats.performanceHistory.shift();
                        }

                        frames = 0;
                        lastTime = currentTime;
                    }

                    requestAnimationFrame(measurePerformance);
                };

                requestAnimationFrame(measurePerformance);
            }

            getAveragePerformance() {
                if (this.messageStats.performanceHistory.length === 0) return 60;
                return this.messageStats.performanceHistory.reduce((a, b) => a + b, 0) /
                    this.messageStats.performanceHistory.length;
            }

            startAdaptiveCleanup() {
                setInterval(() => {
                    this.adaptiveCleanup();
                }, this.cleanupConfig.cleanupInterval);
            }
            setupScrollHandlers() {
                const chatContainer = document.getElementById('chat-container');

                // Отслеживаем начало прокрутки пользователем
                chatContainer.addEventListener('mousewheel', () => {
                    this.isUserScrolling = true;
                    if (this.scrollTimeout) {
                        clearTimeout(this.scrollTimeout);
                    }
                    this.scrollTimeout = setTimeout(() => {
                        this.isUserScrolling = false;
                    }, 150);
                }, { passive: true });

                // Отслеживаем позицию прокрутки
                chatContainer.addEventListener('scroll', () => {
                    if (!this.isCleanupInProgress) {
                        this.lastScrollPosition = chatContainer.scrollTop;
                    }
                }, { passive: true });
            }
            async smoothCleanup(messages, criteria) {
                if (this.isCleanupInProgress) return;

                const chatContainer = document.getElementById('chat-container');
                const wasAtBottom = this.isScrolledToBottom(chatContainer);
                const initialScrollTop = chatContainer.scrollTop;

                this.isCleanupInProgress = true;
                const messagesToRemove = [];

                // Собираем сообщения для удаления
                Array.from(messages).forEach(message => {
                    if (criteria(message)) {
                        messagesToRemove.push(message);
                    }
                });

                // Разбиваем удаление на батчи
                for (let i = 0; i < messagesToRemove.length; i += this.cleanupConfig.batchSize) {
                    const batch = messagesToRemove.slice(i, i + this.cleanupConfig.batchSize);

                    // Сохраняем высоту перед удалением
                    const heightBefore = chatContainer.scrollHeight;

                    // Удаляем батч сообщений
                    batch.forEach(message => {
                        const height = message.offsetHeight;
                        message.style.height = '0';
                        message.style.margin = '0';
                        message.style.padding = '0';
                        message.style.opacity = '0';
                        message.style.transition = 'all 0.2s ease-out';

                        setTimeout(() => {
                            message.remove();
                        }, 200);
                    });

                    // Корректируем позицию прокрутки
                    const heightAfter = chatContainer.scrollHeight;
                    const heightDiff = heightBefore - heightAfter;

                    if (!wasAtBottom && !this.isUserScrolling) {
                        chatContainer.scrollTop = Math.max(0, initialScrollTop - heightDiff);
                    } else if (wasAtBottom) {
                        chatContainer.scrollTop = chatContainer.scrollHeight;
                    }

                    // Ждем перед следующим батчем
                    await new Promise(resolve => setTimeout(resolve, this.cleanupConfig.cleanupDelay));
                }

                this.isCleanupInProgress = false;
            }
            async adaptiveCleanup() {
                const chatContainer = document.getElementById('chat-container');
                const messages = chatContainer.getElementsByClassName('chat-message');
                const currentTime = Date.now();

                // Проверяем необходимость очистки
                const needsCleanup = this.shouldCleanup(messages.length);

                if (needsCleanup) {
                    const containerRect = chatContainer.getBoundingClientRect();
                    const visibleTop = containerRect.top;
                    const visibleBottom = containerRect.bottom;

                    await this.smoothCleanup(messages, (message) => {
                        const messageRect = message.getBoundingClientRect();
                        const messageTime = parseInt(message.dataset.timestamp || '0');

                        return (messageRect.bottom < visibleTop - 200) || // Выше видимой области
                            (messageRect.top > visibleBottom + 200) || // Ниже видимой области
                            (currentTime - messageTime > this.cleanupConfig.messageRetentionTime); // Старое сообщение
                    });
                }
            }
            applyStyles() {
                document.documentElement.style.setProperty('--font-size', this.fontSize);
                document.documentElement.style.setProperty('--font-family', this.fontFamily);
                const chatContainer = document.getElementById('chat-container');
                chatContainer.style.fontSize = this.fontSize;
                chatContainer.style.fontFamily = this.fontFamily;
                logger.debug(`Applying styles: fontSize=${this.fontSize}, fontFamily=${this.fontFamily}`);
            }
            async connect() {
                logger.info(`Connecting to Twitch chat for channel: ${this.channel}`);

                this.ws = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

                this.ws.onopen = () => {
                    this.ws.send('CAP REQ :twitch.tv/tags twitch.tv/commands twitch.tv/membership');
                    this.ws.send('PASS SCHMOOPIIE');
                    this.ws.send('NICK justinfan12345');
                    this.ws.send(`JOIN #${this.channel}`);
                };
                this.ws.onmessage = async (event) => {
                    const parsedMessage = this.parseMessage(event.data);
                    if (parsedMessage) {
                        this.displayMessage(parsedMessage);
                    }
                };
                this.ws.onclose = () => {
                    logger.warn('Connection lost, attempting to reconnect...');
                    setTimeout(() => {
                        this.connect();
                    }, 1000);
                };

                this.ws.onerror = (error) => {
                    logger.error('WebSocket error:', error);
                    this.ws.close();
                };
                // Загружаем эмоуты после установки обработчиков WebSocket
                try {
                    await emoteCache.fetch7TVEmotes(this.channelId);
                    logger.info('7TV emotes loaded successfully');
                } catch (error) {
                    logger.error('Failed to load 7TV emotes:', error);
                }

            }
            parseEmotes(emoteTag, message) {
                if (!emoteTag || emoteTag === true) return [];

                const emotes = [];
                const emotesArray = emoteTag.split('/');

                for (const emote of emotesArray) {
                    const [emoteId, positions] = emote.split(':');
                    if (!positions) continue;

                    positions.split(',').forEach(position => {
                        const [start, end] = position.split('-').map(Number);
                        emotes.push({
                            id: emoteId,
                            start: start,
                            end: end,
                            name: message.slice(start, end + 1),
                            url: `https://static-cdn.jtvnw.net/emoticons/v2/${emoteId}/default/dark/1.0`
                        });
                    });
                }

                return emotes.sort((a, b) => a.start - b.start);
            }
            parseMessage(rawMessage) {
                if (!rawMessage.includes('PRIVMSG')) return null;

                const parsedMessage = {
                    tags: {},
                    username: '',
                    message: '',
                    badges: []
                };

                if (rawMessage.startsWith('@')) {
                    const tagsEnd = rawMessage.indexOf(' ');
                    const tagsStr = rawMessage.slice(1, tagsEnd);
                    const tagPairs = tagsStr.split(';');

                    for (const tagPair of tagPairs) {
                        const [key, value] = tagPair.split('=');
                        if (key === 'badges' && value && value !== 'true') {
                            parsedMessage.badges = value.split(',');
                        }
                        parsedMessage.tags[key] = value || true;
                    }

                    rawMessage = rawMessage.slice(tagsEnd + 1);
                }

                const usernameMatch = rawMessage.match(/:([^!]+)/);
                const messageParts = rawMessage.split(' :');

                parsedMessage.username = usernameMatch ? usernameMatch[1] : '';
                parsedMessage.message = messageParts.length > 1 ? messageParts[1] : '';

                this.logger.debug(parsedMessage);
                return parsedMessage;
            }
            isScrolledToBottom(container) {
                const tolerance = 50; // пикселей от нижней границы
                return container.scrollHeight - container.clientHeight <= container.scrollTop + tolerance;
            }

            shouldCleanup(messageCount) {
                return messageCount > this.cleanupConfig.minMessagesBeforeCleanup &&
                    (messageCount > this.cleanupConfig.maxMessagesBeforeForceCleanup ||
                        this.getAveragePerformance() < this.cleanupConfig.performanceThreshold ||
                        this.messageStats.messagesPerSecond > 30);
            }
            async displayMessage(parsedMessage) {
                if (parsedMessage.tags['display-name'] && parsedMessage.tags.color) {
                    this.userColors.set(
                        parsedMessage.tags['display-name'].toLowerCase(),
                        parsedMessage.tags.color
                    );
                }
                const chatContainer = document.getElementById('chat-container');
                const wasAtBottom = this.isScrolledToBottom(chatContainer);
                const messageElement = document.createElement('div');
                messageElement.className = 'chat-message';
                const badgesContainer = document.createElement('span');
                badgesContainer.className = 'badges-container';
                messageElement.dataset.timestamp = Date.now().toString();

                if (parsedMessage.tags['first-msg'] === '1') {
                    messageElement.classList.add('first-message');
                }
                if (parsedMessage.tags['custom-reward-id']) {
                    messageElement.classList.add('channel-reward');
                }
                if (parsedMessage.tags['msg-id'] === 'highlighted-message') {
                    messageElement.classList.add('highlighted-message');
                }
                const normalizedChannel = this.channel.toLowerCase();
                const normalizedMessage = parsedMessage.message.toLowerCase();
                if (normalizedMessage.includes(normalizedChannel)) {
                    logger.info(`Highlighting message: "${parsedMessage.message}"`);
                    messageElement.classList.add('highlighted-message');
                }

                // Проверяем, что badges существует и является массивом
                if (Array.isArray(parsedMessage.badges) && parsedMessage.badges.length > 0) {
                    parsedMessage.badges.forEach(badge => {
                        const [badgeType] = badge.split('/');
                        if (this.badgeUrls[badgeType]) {
                            const badgeImg = document.createElement('img');
                            badgeImg.src = this.badgeUrls[badgeType];
                            badgeImg.alt = badgeType;
                            badgeImg.className = 'chat-badge';
                            badgesContainer.appendChild(badgeImg);
                        }
                    });
                }
                const usernameElement = document.createElement('span');
                usernameElement.className = 'username';
                usernameElement.textContent = parsedMessage.tags['display-name'] || parsedMessage.username;
                usernameElement.style.color = parsedMessage.tags.color || 'var(--default-name-color)';
                const messageContent = document.createElement('div');
                messageContent.className = 'message-content';

                messageElement.appendChild(badgesContainer);
                messageElement.appendChild(usernameElement);
                messageElement.appendChild(messageContent);
                chatContainer.appendChild(messageElement);

                await processMessageContent(
                    messageContent,
                    parsedMessage.message,
                    parsedMessage,
                    this.isTypewriterEffect,
                    this.typewriterSpeed,
                    this.userColors
                );
                chatContainer.appendChild(messageElement);
                // Прокручиваем к новому сообщению
                messageElement.scrollIntoView({ behavior: 'smooth', block: 'end' });
                // Дополнительно обеспечиваем прокрутку контейнера
                chatContainer.appendChild(messageElement);

                // Проверяем необходимость очистки при высокой нагрузке
                if (this.messageStats.messagesPerSecond > 30) {
                    this.adaptiveCleanup();
                }

                // Прокручиваем только если были внизу до добавления сообщения
                if (wasAtBottom && !this.isUserScrolling) {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                }
            }
        }
        // Инициализация
        const urlParams = new URLSearchParams(window.location.search);
        const channel = urlParams.get('channel') || 'your_channel_name';
        const channelId = urlParams.get('channelId') || 'your_channel_id';
        const isTypewriterEffect = urlParams.get('typewriterEffect') === 'true';
        const typewriterSpeed = parseInt(urlParams.get('typewriterSpeed'), 10) || 50;
        const fontSize = urlParams.get('fontSize') || '14px';
        const fontFamily = urlParams.get('fontFamily') || 'sans-serif';
        const win11Style = urlParams.get('win11') === 'true';
        const debugMode = urlParams.get('debug') === 'true';

        // Создаем логгер
        const logger = new Logger(debugMode);

        // Создаем чат
        const chat = new TwitchChat(
            channel,
            channelId,
            isTypewriterEffect,
            typewriterSpeed,
            fontSize,
            fontFamily,
            logger,
            win11Style  // Добавляем параметр win11Style в конструктор
        );
    </script>
</body>

</html>
