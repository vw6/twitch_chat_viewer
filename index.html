<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitch Chat Overlay with 7TV</title>
    <style>
        :root {
            --chat-background: rgba(18, 18, 18, 0.8);
            --message-background: rgba(30, 30, 30, 0.6);
            --text-color: #ffffff;
            --default-name-color: #ff4081;
            --border-radius: 8px;
            --font-size: 16px;
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            --emote-size-multiplier: 1.75;
            --emote-size: calc(var(--font-size) * var(--emote-size-multiplier));
            --container-width: 100%;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-family);
            background: transparent;
            color: var(--text-color);
            font-size: var(--font-size);
            display: flex;
            flex-direction: column;
        }

        *,
        *:before,
        *:after {
            box-sizing: border-box;
        }

        #chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px;
            background: var(--chat-background);
            border-radius: var(--border-radius);
            position: relative;
            scrollbar-width: none;
            -ms-overflow-style: none;
            margin: 16px;
            max-width: calc(100% - 32px);
        }

        #chat-container::-webkit-scrollbar {
            display: none;
        }

        /* Добавляем перенос текста и ограничение ширины блока сообщения */
        .chat-message {
            padding: 8px 12px;
            background: var(--message-background, #25252b);
            border-radius: var(--border-radius, 6px);
            animation: slideIn 0.3s ease-out;
            margin-bottom: 8px;
            line-height: 1.4;
            max-width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            display: block;
            clear: both;
            font-size: inherit;
            /* Шрифт унаследован, будет меняться через JavaScript */
            font-family: inherit;
            /* Шрифт унаследован, будет меняться через JavaScript */
        }

        .message-content {
            display: block;
            /* Текст сообщения обтекает бейджи и имя */
            word-break: break-word;
            /* Разрешаем перенос длинных слов */
            overflow-wrap: break-word;
            /* Перенос слов для совместимости */
            margin-top: 4px;
            /* Небольшой отступ сверху */
            clear: both;
            /* Текст начинается под именем и бейджами */
        }

        .username {
            float: left;
            /* Имя выравнивается влево рядом с бейджами */
            font-weight: 600;
            display: inline-block;
            /* Имя пользователя на одной линии */
            white-space: nowrap;
            /* Запрещаем перенос имени */
            vertical-align: middle;
            /* Выравнивание имени */
            margin-right: 8px;
            /* Отступ между именем и текстом */
            color: var(--default-name-color);
        }

        .chat-message .username {
            font-weight: 600;
            display: inline;
            white-space: nowrap;
            margin-right: 4px;
            color: var(--default-name-color);
        }

        .message-content {
            display: block;
            /* Текст сообщения обтекает бейджи и имя */
            word-break: break-word;
            /* Разрешаем перенос длинных слов */
            overflow-wrap: break-word;
            /* Перенос слов для совместимости */
            margin-top: 4px;
            /* Небольшой отступ сверху */
            clear: both;
            /* Текст начинается под именем и бейджами */
        }

        .chat-message .message-content {
            display: inline;
            /* Текст идет сразу за именем */
            word-break: break-word;
        }

        .username::after {
            content: ': ';
            white-space: pre;
        }

        .message-wrapper {
            display: inline-flex;
            flex-wrap: wrap;
            min-width: 0;
            max-width: 100%;
            word-wrap: break-word;
        }

        .message {
            display: inline;
            word-break: break-word;
            white-space: pre-wrap;
            max-width: 100%;
            overflow-wrap: break-word;
        }

        .emote {
            height: var(--emote-size);
            width: auto;
            max-width: calc(var(--emote-size) * 1.5);
            vertical-align: middle;
            object-fit: contain;
            display: inline-block;
            margin: 0 2px;
            transition: opacity 0.2s ease-in-out;
        }

        .badges-container {
            float: left;
            /* Бейджи выравниваются влево */
            display: inline-block;
            /* Бейджи на одной линии */
            vertical-align: middle;
            /* Выравнивание по вертикали */
            margin-right: 4px;
            /* Отступ между бейджами и именем */
        }

        .chat-badge {
            width: 18px;
            /* Размер бейджа */
            height: 18px;
            display: inline-block;
            vertical-align: middle;
            /* Выравнивание бейджей */
        }

        .highlighted-message {
            background-color: rgba(255, 0, 0, 0.1);
            /* Полупрозрачный красный фон */
            border-left: 4px solid #ff0000;
            /* Ярко-красная полоса слева */
            border-right: 4px solid #ff0000;
            /* Ярко-красная полоса слева */
            padding: 6px 10px;
            /* Внутренние отступы */
            border-radius: 4px;
            /* Закруглённые углы */
            color: inherit;
            /* Наследуем цвет текста */
        }

        .chat-link {
            color: #00b7ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .chat-link:hover {
            color: #66d9ff;
            text-decoration: underline;
        }

        .chat-command {
            color: #ff9966;
            font-weight: bold;
        }

        @keyframes slideIn {
            from {
                transform: translateX(-20px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <div id="chat-container"></div>
    <script>
        class Logger {
            constructor(debugMode = false) {
                this.debugMode = debugMode;
                this.styles = {
                    debug: 'color: #7CB9E8', // Light blue for debug
                    info: 'color: #98FB98',  // Light green for info
                    warn: 'color: #FFD700',  // Gold for warnings
                    error: 'color: #FF6B6B', // Soft red for errors
                    timestamp: 'color: #C0C0C0', // Silver for timestamp
                    username: 'font-weight: bold', // Bold for usernames
                };
            }

            formatTimestamp(date) {
                return date.toISOString().split('T')[1].slice(0, -1);
            }

            formatMessage(level, message, object = null) {
                const timestamp = this.formatTimestamp(new Date());
                return `%c[${timestamp}] %c[${level.toUpperCase()}] ${message}`;
            }

            log(level, message, object = null) {
                if (!this.debugMode && level === 'debug') return;

                const formattedMessage = this.formatMessage(level, message);

                console.log(
                    formattedMessage,
                    this.styles.timestamp,
                    this.styles[level]
                );

                if (object) {
                    console.log('Details:', object);
                }
            }

            debug(message) {
                if (typeof message === 'object' && message.tags && message.tags['display-name'] && message.message) {
                    const username = message.tags['display-name'];
                    const chatMessage = message.message.trim();

                    // Format chat message for better readability
                    console.log(
                        `%c[${this.formatTimestamp(new Date())}] %c[DEBUG] %c${username}: %c${chatMessage}`,
                        this.styles.timestamp,
                        this.styles.debug,
                        this.styles.username,
                        'color: white'
                    );

                    // Log additional details in collapsed group if needed
                    if (Object.keys(message.tags).length > 0) {
                        console.groupCollapsed('Message Details');
                        console.log('Tags:', message.tags);
                        console.log('Badges:', message.badges);
                        console.groupEnd();
                    }
                } else {
                    this.log('debug', typeof message === 'string' ? message : JSON.stringify(message));
                }
            }

            info(message) {
                this.log('info', message);
            }

            warn(message) {
                this.log('warn', message);
            }

            error(message) {
                this.log('error', message);
                if (message instanceof Error) {
                    console.error('Stack trace:', message.stack);
                }
            }
        }

        class EmoteCache {
            constructor() {
                this.emotes = new Map();
            }

            async fetch7TVEmotes(channelId) {
                try {
                    const response = await fetch(`https://7tv.io/v3/users/twitch/${channelId}`);
                    if (!response.ok) throw new Error(`Failed to fetch 7TV emotes: ${response.status}`);
                    const data = await response.json();

                    if (data && data.emote_set && data.emote_set.emotes) {
                        data.emote_set.emotes.forEach(emote => {
                            this.emotes.set(emote.name, `https://cdn.7tv.app/emote/${emote.id}/3x.webp`);
                        });
                    }
                } catch (error) {
                    logger.error('Error fetching 7TV emotes:', error);
                }
            }

            getEmoteUrl(emoteName) {
                return this.emotes.get(emoteName);
            }
        }

        const emoteCache = new EmoteCache();

        async function processMessageContent(container, text, isTypewriterEffect, typewriterSpeed, userColors = new Map()) {
            const words = text.split(/\s+/);
            const urlRegex = /(https?:\/\/[^\s]+)/;
            const commandRegex = /^!/;

            for (const word of words) {
                if (word.startsWith('@')) {
                    // Обработка тега пользователя
                    const username = word.slice(1).toLowerCase();
                    const tagSpan = document.createElement('span');

                    if (isTypewriterEffect) {
                        for (const char of word) {
                            const charSpan = document.createElement('span');
                            charSpan.textContent = char;
                            if (userColors.has(username)) {
                                charSpan.style.color = userColors.get(username);
                                charSpan.style.fontWeight = 'bold';
                            }
                            tagSpan.appendChild(charSpan);
                            await new Promise(resolve => setTimeout(resolve, typewriterSpeed));
                        }
                        tagSpan.appendChild(document.createTextNode(' '));
                    } else {
                        tagSpan.textContent = word + ' ';
                        if (userColors.has(username)) {
                            tagSpan.style.color = userColors.get(username);
                            tagSpan.style.fontWeight = 'bold';
                        }
                    }
                    container.appendChild(tagSpan);
                } else if (urlRegex.test(word)) {
                    // Обработка ссылок
                    const linkElement = document.createElement('a');
                    linkElement.href = word;
                    linkElement.className = 'chat-link';
                    linkElement.target = '_blank';
                    linkElement.rel = 'noopener noreferrer';

                    if (isTypewriterEffect) {
                        for (const char of word) {
                            const charSpan = document.createElement('span');
                            charSpan.textContent = char;
                            linkElement.appendChild(charSpan);
                            await new Promise(resolve => setTimeout(resolve, typewriterSpeed));
                        }
                    } else {
                        linkElement.textContent = word;
                    }

                    container.appendChild(linkElement);
                    container.appendChild(document.createTextNode(' '));
                } else if (commandRegex.test(word)) {
                    // Обработка команд
                    const commandSpan = document.createElement('span');
                    commandSpan.className = 'chat-command';

                    if (isTypewriterEffect) {
                        for (const char of word) {
                            const charSpan = document.createElement('span');
                            charSpan.textContent = char;
                            commandSpan.appendChild(charSpan);
                            await new Promise(resolve => setTimeout(resolve, typewriterSpeed));
                        }
                    } else {
                        commandSpan.textContent = word;
                    }

                    container.appendChild(commandSpan);
                    container.appendChild(document.createTextNode(' '));
                } else {
                    const emoteUrl = emoteCache.getEmoteUrl(word);
                    if (emoteUrl) {
                        const emoteImg = document.createElement('img');
                        emoteImg.src = emoteUrl;
                        emoteImg.alt = word;
                        emoteImg.className = 'emote';
                        container.appendChild(emoteImg);
                    } else if (isTypewriterEffect) {
                        for (const char of word) {
                            const charNode = document.createTextNode(char);
                            container.appendChild(charNode);
                            await new Promise(resolve => setTimeout(resolve, typewriterSpeed));
                        }
                        container.appendChild(document.createTextNode(' '));
                    } else {
                        const textNode = document.createTextNode(`${word} `);
                        container.appendChild(textNode);
                    }
                }
            }
        }


        class TwitchChat {
            constructor(channel, channelId, isTypewriterEffect, typewriterSpeed, fontSize, fontFamily) {
                this.channel = channel.toLowerCase();
                this.channelId = channelId;
                this.isTypewriterEffect = isTypewriterEffect;
                this.typewriterSpeed = typewriterSpeed;
                this.fontSize = fontSize;
                this.fontFamily = fontFamily;
                this.userColors = new Map();

                // Initialize other properties as before
                this.badgeUrls = {
                    broadcaster: 'https://static-cdn.jtvnw.net/badges/v1/5527c58c-fb7d-422d-b71b-f309dcb85cc1/3',
                    moderator: 'https://static-cdn.jtvnw.net/badges/v1/3267646d-33f0-4b17-b3df-f923a41db1d0/3',
                    vip: 'https://static-cdn.jtvnw.net/badges/v1/b817aba4-fad8-49e2-b88a-7cc744dfa6ec/3',
                    subscriber: 'https://static-cdn.jtvnw.net/badges/v1/f3130f22-0a46-4bce-97fe-9a0729fcb055/3',
                    premium: 'https://static-cdn.jtvnw.net/badges/v1/bbbe0db0-a598-423e-86d0-f9fb98ca1933/3',
                    partner: 'https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f6-41d0-ab77-b780518f00a3/3'
                };

                this.applyStyles();
                this.connect();
            }

            applyStyles() {
                const chatContainer = document.getElementById('chat-container');
                chatContainer.style.fontSize = this.fontSize;
                chatContainer.style.fontFamily = this.fontFamily;
                logger.debug(`Applying styles: fontSize=${this.fontSize}, fontFamily=${this.fontFamily}`);
            }

            async connect() {
                logger.info(`Connecting to Twitch chat for channel: ${this.channel}`);
                await emoteCache.fetch7TVEmotes(this.channelId);

                const ws = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
                ws.onopen = () => {
                    ws.send('CAP REQ :twitch.tv/tags twitch.tv/commands twitch.tv/membership');
                    ws.send('PASS SCHMOOPIIE');
                    ws.send('NICK justinfan12345');
                    ws.send(`JOIN #${this.channel}`);
                };

                ws.onmessage = async (event) => {
                    const parsedMessage = this.parseMessage(event.data);
                    if (parsedMessage) {
                        this.displayMessage(parsedMessage);
                    }
                };
            }

            parseMessage(rawMessage) {
                if (!rawMessage.includes('PRIVMSG')) return null;

                const parsedMessage = {
                    tags: {},
                    username: '',
                    message: '',
                    badges: []
                };

                if (rawMessage.startsWith('@')) {
                    const tagsEnd = rawMessage.indexOf(' ');
                    const tagsStr = rawMessage.slice(1, tagsEnd);
                    const tagPairs = tagsStr.split(';');

                    for (const tagPair of tagPairs) {
                        const [key, value] = tagPair.split('=');
                        if (key === 'badges' && value && value !== 'true') {
                            parsedMessage.badges = value.split(',');
                        }
                        parsedMessage.tags[key] = value || true;
                    }

                    rawMessage = rawMessage.slice(tagsEnd + 1);
                }

                const usernameMatch = rawMessage.match(/:([^!]+)/);
                const username = usernameMatch ? usernameMatch[1] : '';
                const messageParts = rawMessage.split(' :');
                const message = messageParts.length > 1 ? messageParts[1] : '';

                parsedMessage.username = username;
                parsedMessage.message = message;

                logger.debug(parsedMessage);
                return parsedMessage;
            }

            async displayMessage(parsedMessage) {
                if (parsedMessage.tags['display-name'] && parsedMessage.tags.color) {
                    this.userColors.set(
                        parsedMessage.tags['display-name'].toLowerCase(),
                        parsedMessage.tags.color
                    );
                }

                const chatContainer = document.getElementById('chat-container');
                const messageElement = document.createElement('div');
                messageElement.className = 'chat-message';

                const badgesContainer = document.createElement('span');
                badgesContainer.className = 'badges-container';

                // Проверяем, что badges существует и является массивом
                if (Array.isArray(parsedMessage.badges) && parsedMessage.badges.length > 0) {
                    parsedMessage.badges.forEach(badge => {
                        const [badgeType] = badge.split('/');
                        if (this.badgeUrls[badgeType]) {
                            const badgeImg = document.createElement('img');
                            badgeImg.src = this.badgeUrls[badgeType];
                            badgeImg.alt = badgeType;
                            badgeImg.className = 'chat-badge';
                            badgesContainer.appendChild(badgeImg);
                        }
                    });
                }

                const usernameElement = document.createElement('span');
                usernameElement.className = 'username';
                usernameElement.textContent = parsedMessage.tags['display-name'] || parsedMessage.username;
                usernameElement.style.color = parsedMessage.tags.color || 'var(--default-name-color)';

                const messageContent = document.createElement('div');
                messageContent.className = 'message-content';

                const normalizedChannel = this.channel.toLowerCase();
                const normalizedMessage = parsedMessage.message.toLowerCase();

                if (normalizedMessage.includes(normalizedChannel)) {
                    logger.info(`Highlighting message: "${parsedMessage.message}"`);
                    messageElement.classList.add('highlighted-message');
                }

                messageElement.appendChild(badgesContainer);
                messageElement.appendChild(usernameElement);
                messageElement.appendChild(messageContent);
                chatContainer.appendChild(messageElement);

                await processMessageContent(
                    messageContent,
                    parsedMessage.message,
                    this.isTypewriterEffect,
                    this.typewriterSpeed,
                    this.userColors
                );
                // Прокручиваем к новому сообщению
                messageElement.scrollIntoView({ behavior: 'smooth', block: 'end' });

                // Дополнительно обеспечиваем прокрутку контейнера
                chatContainer.scrollTop = chatContainer.scrollHeight;

                setTimeout(() => {
                    if (chatContainer.contains(messageElement)) {
                        chatContainer.removeChild(messageElement);
                    }
                }, 60000);
            }
        }

        const urlParams = new URLSearchParams(window.location.search);
        const channel = urlParams.get('channel') || 'your_channel_name';
        const channelId = urlParams.get('channelId') || 'your_channel_id';
        const isTypewriterEffect = urlParams.get('typewriterEffect') === 'true';
        const typewriterSpeed = parseInt(urlParams.get('typewriterSpeed'), 10) || 50;
        const fontSize = urlParams.get('fontSize') || '14px';
        const fontFamily = urlParams.get('fontFamily') || 'sans-serif';
        const debugMode = urlParams.get('debug') === 'true';

        const logger = new Logger(debugMode);
        new TwitchChat(channel, channelId, isTypewriterEffect, typewriterSpeed, fontSize, fontFamily);
    </script>
</body>

</html>